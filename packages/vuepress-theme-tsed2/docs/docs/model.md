---
meta:
 - name: description
   content: Documentation over Models and decorators provided by Ts.ED framework. Use decorator to build your model and JsonSchema.
 - name: keywords
   content: class model decorators ts.ed express typescript node.js javascript jsonschema
---
# Model

The classes can be used as a model in your application.
Ts.ED uses these models to convert JSON objects to their class equivalents.

The classes models can be used in the following cases:

- Data serialization and deserialization ([Json mapping](/docs/converters.md)),
- Data validation with [AJV](/tutorials/ajv.md) or any library compatible with [JsonSchema](https://json-schema.org/),
- Generating documentation with [Swagger](/tutorials/swagger.md).

To create a model, Ts.ED provides decorators which will store and generate a 
standard [JsonSchema](http://json-schema.org/) model.

::: warning
Validation is only available when you import `@tsed/ajv` package in your server.

```typescript
import {Configuration} from "@tsed/common";
import "@tsed/ajv";

@Configuration()
class Server {}
```

Without this package, decorators like @@Email@@ won't have any effect.
:::

## Example

The example below uses decorators to describe a property of the class and store metadata
such as the description of the field.

<<< @/docs/docs/snippets/model/example.ts

::: tip
The Model will generate a JsonSchema which can be used by modules supporting JsonSchema spec
:::

::: warning
The schema generated by Ts.ED lists only properties decorated by at least one decorator. In the previous example,
the `_id` won't be displayed in the JsonSchema. It's very important to understand that **TypeScript** only generates
 metadata on properties with at least of theses decorators:

<ApiList query="module === '@tsed/schema' && status.includes('decorator') && status.includes('schema')" />

:::

Our model is now described, we can use it inside a @@Controller@@ as input type parameter for our methods. 
Ts.ED will use the model to convert the raw data to an instance of your model.

<<< @/docs/docs/snippets/model/controller.ts

## Primitives

Just use at least @@Property@@ decorator any other `schema` decorator (like @@Email@@), to create a new property on a model.
Ts.ED will get the type from Typescript metadata and transform this type to a valid Json type.

<Tabs class="-code">
  <Tab label="Model">
  
<<< @/docs/docs/snippets/model/primitives.ts

  </Tab>
  <Tab label="Json schema">
    
<<< @/docs/docs/snippets/model/primitives.json
  
  </Tab>
</Tabs>

## Integer <Badge text="v5.62.0+" />

The @@Integer@@ decorator is used to set integer type for integral numbers.

<Tabs class="-code">
  <Tab label="Model">
  
<<< @/docs/docs/snippets/model/integer.ts

  </Tab>
  <Tab label="Json schema">
    
<<< @/docs/docs/snippets/model/integer.json
  
  </Tab>
</Tabs>

## Any types

The @@Any@@ (before v5.62.0, use @@AllowTypes@@) decorator is used to set one or more types on property. Use this method when you when to set explicitly the json type
or when you use a mixed TypeScript types.

<Tabs class="-code">
  <Tab label="Model">
  
<<< @/docs/docs/snippets/model/any-types.ts

  </Tab>
  <Tab label="Json schema">
    
<<< @/docs/docs/snippets/model/any-types.json
  
  </Tab>
</Tabs>

## Regular expressions

The @@Pattern@@ decorator is used to restrict a string to a particular regular expression. 
The regular expression syntax is the one defined in JavaScript ([ECMA 262](https://www.ecma-international.org/publications/standards/Ecma-262.htm) specifically). 
See [Regular Expressions](https://json-schema.org/understanding-json-schema/reference/regular_expressions.html#regular-expressions) for more information.

<Tabs class="-code">
  <Tab label="Model">
  
<<< @/docs/docs/snippets/model/pattern.ts

  </Tab>
  <Tab label="Json schema">
    
<<< @/docs/docs/snippets/model/pattern.json
  
  </Tab>
</Tabs>

## Format

The @@Format@@ decorator allows for basic semantic validation on certain kinds of string values that are commonly used. 
This allows values to be constrained beyond what the other tools in JSON Schema, including [Regular Expressions](https://json-schema.org/understanding-json-schema/reference/regular_expressions.html#regular-expressions) 
can do.

<Tabs class="-code">
  <Tab label="Model">
  
<<< @/docs/docs/snippets/model/format.ts

  </Tab>
  <Tab label="Json schema">
    
<<< @/docs/docs/snippets/model/format.json
  
  </Tab>
</Tabs>

The following formats are supported for string validation with `format` keyword by [AJV](https://ajv.js.org/):

- **date**: full-date according to [RFC3339](https://json-schema.org/latest/json-schema-validation.html#RFC3339).
- **time**: time with optional time-zone.
- **date-time**: date-time from the same source (time-zone is mandatory).
- **uri**: full uri with optional protocol.
- **email**: email address.
- **hostname**: host name according to [RFC1034](https://tools.ietf.org/html/rfc1034#section-3.1).
- **ipv4**: IP address v4.
- **ipv6**: IP address v6.
- **regex**: tests whether a string is a valid regular expression by passing it to RegExp constructor.

See built-in formats types on [Jsonp-schema.org](https://json-schema.org/understanding-json-schema/reference/string.html#built-in-formats) for more details:

## MultipleOf

Numbers can be restricted to a multiple of a given number, using the @@MultipleOf@@ decorator. 
It may be set to any positive number.
See [json-schema documentation](https://json-schema.org/understanding-json-schema/reference/numeric.html#multiples) for more details.

<Tabs class="-code">
  <Tab label="Model">
  
<<< @/docs/docs/snippets/model/multiple-of.ts

  </Tab>
  <Tab label="Json schema">
    
<<< @/docs/docs/snippets/model/multiple-of.json
  
  </Tab>
</Tabs>

## Ranges

Ranges of numbers are specified using a combination of the @@Minimum@@ and @@Maximum@@ decorators, (or @@ExclusiveMinimum@@ and @@ExclusiveMaximum@@ for expressing exclusive range).
See [json-schema documentation](https://json-schema.org/understanding-json-schema/reference/numeric.html#multiples) for more details.

<Tabs class="-code">
  <Tab label="Model">
  
<<< @/docs/docs/snippets/model/ranges.ts

  </Tab>
  <Tab label="Json schema">
    
<<< @/docs/docs/snippets/model/ranges.json
  
  </Tab>
</Tabs>

## Enumerated values

The @@Enum@@ decorator is used to restrict a value to a fixed set of values.
It must be an array with at least one element, where each element is unique or a TypeScript enum.

<Tabs class="-code">
  <Tab label="Model">
  
<<< @/docs/docs/snippets/model/enumerated-values.ts

  </Tab>
  <Tab label="Json schema">
    
<<< @/docs/docs/snippets/model/enumerated-values.json
  
  </Tab>
</Tabs>

## Constant values

The @@Const@@ decorator is used to restrict a value to a single value.
For example, to if you only support shipping to the United States for export reasons:

<Tabs class="-code">
  <Tab label="Model">
  
<<< @/docs/docs/snippets/model/required-properties.ts

  </Tab>
  <Tab label="Json schema">
    
<<< @/docs/docs/snippets/model/required-properties.json
  
  </Tab>
</Tabs>

## Collections

Declaring a property that uses a collection is a bit different than declaring a simple property. TypeScript 
stores only the Array/Set/Map type when you declare the type of your property. The type used by the collection is lost.

To tell Ts.ED (and other third party which uses JsonSchema) that a property uses a collection with a specific type, you must 
use @@CollectionOf@@ (before v5.62.0, use @@PropertyType@@) decorator as following:

<Tabs class="-code">
  <Tab label="Model">
  
<<< @/docs/docs/snippets/model/collections.ts

  </Tab>
  <Tab label="Json schema">
    
<<< @/docs/docs/snippets/model/collections.json
  
  </Tab>
</Tabs>

Ts.ED provide others related collection decorators:

<ApiList query="status.includes('decorator') && status.includes('schema') && status.includes('collections')" />

## Required properties

By default, the properties defined with a decorator are not `required`. 
However, one can use @@Required@@ decorator to add a required property to the json schema.

## Additional properties

Sometimes, it can be useful to create model with additional properties. 
By default, Json schema is strict over extra properties not declared in a model (see [Properties json schema documentation](https://json-schema.org/understanding-json-schema/reference/object.html#properties)).

Use @@AdditionalProperties@@ on your model to allow this behavior:

<Tabs class="-code">
  <Tab label="Model">
  
<<< @/docs/docs/snippets/model/additional-properties.ts

  </Tab>
  <Tab label="Json schema">
    
<<< @/docs/docs/snippets/model/additional-properties.json
  
  </Tab>
</Tabs>

It also possible to add contraint on additional properties, by giving a raw Json schema:

<Tabs class="-code">
  <Tab label="Model">
  
<<< @/docs/docs/snippets/model/additional-properties-with-schema.ts

  </Tab>
  <Tab label="Json schema">
    
<<< @/docs/docs/snippets/model/additional-properties-with-schema.json
  
  </Tab>
</Tabs>

Or by using @@getJsonSchema@@ in combination with @@AdditionalProperty@@ as following:

<Tabs class="-code">
  <Tab label="Model">
  
<<< @/docs/docs/snippets/model/additional-properties-with-model.ts

  </Tab>
  <Tab label="Json schema">
    
<<< @/docs/docs/snippets/model/additional-properties-with-model.json
  
  </Tab>
</Tabs>

## Generics
### Declaring a generic model

Sometime, it might be useful to use generic models. TypeScript doesn't store the generic type in the metadata. This is why we need to
declare explicitly the generic models with the decorators.

One of the generic's usage, can be a paginated list. With Returns decorator it's now possible to declare generic type and generate the appropriate OpenSpec documentation.

Starting with the pagination model, by using @@Generics@@ and @@CollectionOf@@:

<<< @/docs/docs/snippets/model/generics-pagination.ts

Now, we need a model to be used with the generic Pagination model:

<<< @/docs/docs/snippets/model/generics-product.ts

Finally, we can use our models on a method as following:

<Tabs class="-code">
 <Tab label="MyController.ts">
 
<<< @/docs/docs/snippets/model/generics-controller1.ts

 </Tab>
 <Tab label="OpenSpec 2">

<<< @/docs/docs/snippets/model/generics-controller1-os2.json
 
 </Tab>
 <Tab label="OpenSpec 3">

<<< @/docs/docs/snippets/model/generics-controller1-os3.json
 
 </Tab>
</Tabs>

### Declaring a nested generics models

It's also possible to declare a nested generics models in order to have this type `Pagination<Submission<Product>>`:

<Tabs class="-code">
  <Tab label="MyController.ts">
  
```typescript
import {Generics, Property, Returns} from "@tsed/schema";
import {Post} from "@tsed/common";

class MyController {
  @Post("/")
  @Returns(200, Pagination).Of(Submission).Nested(Product).Description("description")
  async method(): Promise<Pagination<Submission<Product>> | null> {
    return null;
  }
}
```
  
  </Tab>
  <Tab label="Submission.ts">

<<< @/docs/docs/snippets/model/generics-submission.ts

  </Tab>
  <Tab label="Pagination.ts">

<<< @/docs/docs/snippets/model/generics-pagination.ts
  
  </Tab>
  <Tab label="Product.ts">

<<< @/docs/docs/snippets/model/generics-product.ts  
  
  </Tab>
 <Tab label="OpenSpec 2">

<<< @/docs/docs/snippets/model/generics-controller2-os2.json
 
 </Tab>
 <Tab label="OpenSpec 3">

<<< @/docs/docs/snippets/model/generics-controller2-os3.json
 
 </Tab>  
</Tabs>  
   


## Annotations

JSON Schema includes a few keywords and Ts.ED provide also theses corresponding decorators like @@Title@@, @@Description@@, @@Default@@, @@Examples@@ that aren’t strictly used for validation, but are used to describe parts of a schema.

None of these `annotation` keywords are required, but they are encouraged for good practice, and can make your schema `self-documenting`.

<Tabs class="-code">
  <Tab label="Model">
  
<<< @/docs/docs/snippets/model/annotations.ts

  </Tab>
  <Tab label="Json schema">
    
<<< @/docs/docs/snippets/model/annotations.json
  
  </Tab>
</Tabs>

<!--
## Rename property (v6)

@@Name@@ decorator let you to rename the exposed property in your json schema. 

For example mongo db uses the `_id` property. 
In order not to give any indication to our consumer about the nature of the database, it's better to rename the property to `id`.

<Tabs class="-code">
  <Tab label="Model">
  
<<< @/docs/docs/snippets/model/name.ts

  </Tab>
  <Tab label="Json schema">
    
<<< @/docs/docs/snippets/model/name.json
  
  </Tab>
</Tabs>

-->

## Set raw schema

If Ts.ED doesn't provide the expected decorator to describe your json schema, you can use the @@Schema@@ decorator from `@tsed/common` to set 
an inline schema:

<Tabs class="-code">
  <Tab label="Model">
  
<<< @/docs/docs/snippets/model/get-spec-generics-controller1.ts  

  </Tab>
  <Tab label="Json schema">
    
<<< @/docs/docs/snippets/model/generics-controller1-os3.json
  
  </Tab>
</Tabs>

## Get Json schema

In some cases, it may be useful to retrieve the JSON Schema from a Model to use with another library.
This is possible by using @@getJsonSchema@@. Here a small example:

<Tabs class="-code">
  <Tab label="Model">

<<< @/docs/docs/snippets/model/jsonschema.ts

  </Tab>
  <Tab label="Json schema">

<<< @/docs/docs/snippets/model/jsonschema.json  

  </Tab>
</Tabs>

## Get OpenSpec

In some cases, it may be useful to retrieve the OpenSpec from a Controller to generate the Swagger OpenSpec.
This is possible by using @@getSpec@@. Here a small example:

<Tabs class="-code">
  <Tab label="MyController">

<<< @/docs/docs/snippets/model/get-spec-generics-controller1.ts

  </Tab>
  <Tab label="OpenSpec">

<<< @/docs/docs/snippets/model/generics-controller1-os3.json 

  </Tab>
</Tabs>

## Decorators

<ApiList query="status.includes('decorator') && status.includes('schema')" />
